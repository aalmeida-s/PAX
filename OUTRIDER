# Expresión aberrante mediante la herramienta OUTRIDER

## Importación de los datos

### En esta parte del proyecto procedimos al estudio valores atípicos en la expresión de las muestras pertenecientes a pacientes PAX. Como el número de muestras disponibles para el estudio era 40 y las necesarias para un buen funcionamiento del programa son entre 50 y 60 decidimos completar la 'n' con una cohorte de 345 muestras de sangre total de individuos sanos de un repositorio público (datos disponibles en el repositorio SRA con número de acceso PRJNA603342). 
Se realizó previamente el alineamiento de los archivos Fastq en el mismo centro donde se procesaron las muestras (CNAG). De esta forma, nosotros partiremos de los archivos de recuento de lecturas sin procesar.
Para proceder al estudio, primero, tenemos que cargar el paquete OUTRIDER que usaremos para ejecutar el análisis de valores atípicos de expresión (a partir de ahora utilizaremos su traducción en inglés *outliers*). Para mapear los nombres de los genes ENSEMBL y los símbolos HGNC usamos anotables. 

library(OUTRIDER)
library(dplyr)
install.packages("devtools")
devtools::install_github("stephenturner/annotables")
library(annotables)

### Para el análisis de detección de *outliers*, necesitamos los recuentos de lecturas sin procesar (que llamaremos `cts`) y una anotación de muestra (que llamaremos `annots`) donde definiremos: nombre (RNA_ID), grupo al que pertenecen (BATCH) y su sexo (Sex). Estos archivos se cargarán en la sesión junto con la base de datos (`txdb_cnag`) que se utilizará para cribar los genes expresados? (...)

library(RSQLite)

filedb<-file.choose()
txdb_cnag<-loadDb(filedb)

filetotalcounts <- file.choose()
total_counts <- readRDS(filetotalcounts)

### Una vez cargado el archivo crudo con toda la información de las muestras (`total_counts`), procederemos a seleccionar los archivos `cts` y `annots`. Además, al archivo de anotado `annots` le añadiremos una columna denominada `sampleID` que necesitará el programa más adelante.

cts<- as.matrix(total_counts@assays@data@listData[["counts"]])
cts[1:5,1:5]
print("Dimensiones de la tabla de contaje:")
dim(cts)

annots <- file.choose()
annots<-read.table(annots, sep = '\t', header = TRUE)
annots<- data.frame(annots)
colnames(annots)
annots<-annots[c("sampleID","DNA_ID","BATCH","Sex")]
head(annots)
print("Dimensiones de la tabla de contaje:")
dim(annots)

### Podemos ver que tenemos 61533 genes y 385 muestras en nuestro experimento, de las cuales sólo 40 pertenecen a nuestro ensayo PAX. Para el contajese usaron todos los genes anotados en la anotación GENCODE v29.

## Filtraje de genes no expresados

### Después, creamos un objeto OUTRIDER (que llamaremos `ods_cnag`) con la anotación cargada y la matriz de conteo sin procesar ejecutando `OutriderDataSet`:

ods_cnag <- OutriderDataSet(countData=cts, colData=annots)

### En este momento es necesario realizar un cribado de todos los genes que no se han expresado. En nuestro caso, al ser muestras de sangre periférica nos interesan los genes expresados en este tejido. Para que la detección de *outliers* sea más robusta tenemos que determinar un buen filtro de expresión de genes (revisar funcion filterExpression para hacer varios controles de expresión). Un buen control de expresión de genes es el parámetro **FPKM** que determina el número de fragmentos por kb por millon de lecturas mapeadas. Para determinar el parámetro FPKM necesitamos la longitud de cada gen, localizada en el archivo de anotado `txdb_cnag` cargado anteriormente.

En este caso vamos a seguir el filtrado estandar manteniendo aquellos genes que tienen un valor de FPKM mayor que 1 en al menos el 5% de las muestras. Utilizaremos el argumento `filterGenes=FALSE` para que nos muestre tanto los genes que han pasado el filtro como los que no.

ods_filtered <- filterExpression(ods_cnag, gtfFile=txdb_cnag, filterGenes=FALSE)
plotFPKM(ods_filtered)

### Ahora seleccionaremos únicamente los genes expresados (4966 genes).

ods_pass_filter <- ods_filtered[mcols(ods_filtered)[,"passedFilter"],]
ods_pass_filter

## Covariación de las muestras

### Por lo general, en los datos de RNA-seq se puede ver la covariación de las muestras en forma de agrupaciones de las cuales se conoce la causa (por ejemplo, sexo, origen, lote), pero a veces proviene de factores de confusión desconocidos. En nuestro caso, el factor de confusión que más nos preocupa es el diferente tratamiento de las muestras ya que se extrajeron y procesaron de forma diferente las pertenecientes al proyecto (comienzan con las letras 'AW' y están nominadas como 'BATCH'= Robleslui_01 y Robleslui_02) y las pertenecientes al repositorio (comienzan con las letras 'SRR' y están nominadas como 'BATCH'= ext).

#### Ajustamos el plot
options(repr.plot.width=6, repr.plot.height=5)

#### Utilizamos normalize=FALSE ya que los datos aun no estan corregidos
plotCountCorHeatmap(ods_pass_filter, colGroups=c("Sex"), rowGroups="BATCH", nRowCluster=4, normalize=FALSE)
```
### Tal y como esperábamos encontramos que las muestras PAX se agrupan entre ellas, confirmando que es un factor de confusión que hay que eliminar

## Deteccion de *outliers*

### Ahora usaremos OUTRIDER para modelar la covariación de la muestra, también llamada *espacio latente*, en función de los datos de expresión génica proporcionados. Usar la dimensión correcta (parámetro 'q') para el espacio latente es crucial para lograr el mejor rendimiento. Esto se puede hacer con `findEncodingDim()`.

#### Búsqueda de la mejor dimension (q) para nuestros datos. (Paso altamente demandante)

ods_pass_filter <- findEncodingDim(ods_pass_filter)
getBestQ(ods_pass_filter)
plotEncDimSearch(ods_pass_filter)

### Una vez encontrado, en nuestro caso q = 18, ajustaremos el modelo para eliminar los factores de confusión y volveremos a generar un *plot* de nuestras muestras.

#### fit the OUTRIDER model
ods_sizeFactors <- estimateSizeFactors(ods_pass_filter)
ods_bestq <- controlForConfounders(ods_sizeFactors, q= 18, iterations=3)
